# Item6. 다 쓴 객체 참조를 해제하라

## 메모리 누수 원인과 해결방법

### Stack

**원인**
- 자기 메모리를 직접 관리하기 때문
- 배열의 활성 영역에 속한 원소들이 사용되고 비활성 영역은 쓰이지 않음.
- 가비지 컬렉터는 비활성 영역 원소가 참조하고 있기 때문에 여전히 쓰인다고 생각함

**해결방법**
- 원소를 다 사용한다면 즉시 `null` 처리

<br>

### Cache

**원인**
- 객체 참조를 캐시에 넣어 둔 뒤, 더이상 사용되지 않아도 계속 남아있는 경우

**해결방법**
- WeakHashMap 이용
  - 외부에서 키를 참조하는 동안만 엔트리가 살아 있는 캐시가 필요할 경우
  - 다 쓴 엔트리는 즉시 자동으로 해제하는 기능을 갖고 있음

- ScheduledThreadPoolExecutor
- LinkedHashMap의 removeEldestEntry
- java.lang.ref 패키지 활용 (복잡한 캐시)

<br>

### Listener, Callback

**원인**
- 클라이언트가 콜백을 등록만 하고 해지하지 않는다면 계속 쌓여감

**해결방법**
- weak reference로 저장하면 가비지 컬렉터가 즉시 수거함
  - e.g. WeakHashMap